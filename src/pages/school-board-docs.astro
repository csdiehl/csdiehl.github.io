---
import ProjectLayout from '../layouts/ProjectLayout.astro';
import { projectData } from "../components/projectData";


const project = projectData.find(x => x.name === "School board documents AI-driven search")

const textBlocks = [
  {
    title: "The problem",
    content: `School board meeting agendas, district planning documents, and meeting transcripts reveal the most pressing issues for parents and students.
      An AP data journalist on the education team built a tool to scrape thousands of school board documents each month.
      They needed a developer to build a database and web app to help reporters search the documents and uncover trends.
      AP recently entered into a partnership with Open AI, so we were interested in exploring solutions that leveraged generative AI.`,
  },
  {
    title: "System Architecture and Design Approach",
    content: `I was the only engineer working on this project, and needed to work within the budget of a nonprofit and time constraints of an active newsroom.
      AP uses AWS for cloud infrastructure, so I set up a postgreSQL database instance to store documents. 
      I developed a NextJS web app, which allowed me to easily organize frontend and backend code and deploy to a serverless stack using SST.
      I set up automated deployments to continously update the app's lamba functions and static assets on S3 while keeping it functional for reporters.`,
  },
  {title: "Challenge: Keyword vs. Vector Search", 
  content: `A signficant consideration that I explored early on was the decision to use keyword search or vector search.
    Vector search offered the potential to type in questions and return context-sensitive results.
    However, it incurred large costs for storing vectors and embedding documents via the OpenAI API.
    I explored an alternative - using AI to generate keywords from an open-ended question and pass those into a Postgres full-text search.\n\n
    
        For this project, scale was a key consideration. We were scraping hundreds of thousands of documents, with plenty added each month.
    On the other hand, the app would have few monthly users as it was intended for journalists and small newsrooms, not the public at large.
    This meant that we needed to optimize for document storage, and could handle the tradeoff of more OpenAI calls for keyword-search queries in exchange for not having to use the embeddings API.
    `},
    {title: `Challenge: Summarizing large documents`, content: `Many documents contained tens of pages of meeting information, which quickly exceeded the LLM's context window.
    To solve this problem, I implemented the map-reduce pattern. I first mapped large documents into smaller chunks, then made an API call to summarize each chunk.
    Then a final prompt instructed the AI to summarize all of the summaries.`},
    {title: `Results`, content: "This is an ongoing effort. So far, nearly 45,000 documents are searchable. The education team uses the tool to find trends and publish stories on top issues."}

  // Add other blocks as needed...
];

const inlineImages = [
  "/school-board/example_doc.png",
  "/school-board/search_page.png",
  "/school-board/ai_summary.png",
];

---

 
  <ProjectLayout 
  mainImage="/school-board/main.png"
  client={project?.client}
  mainTitle="AI-driven school board documents search engine"
  mainDescription="A tool to help journalists search through hundreds of thousands of documents to find key issues in education."
  themeColor="#37AECC"
  secondColor="rgba(55, 174, 204, .3)"
  technologies="PostgreSQL, NextJS, Vercel AI SDK, AWS, Serverless stack"
  projectLink="https://d29ogm19i6xujm.cloudfront.net/"
  textBlocks={textBlocks}
  inlineImages={inlineImages}
/>
